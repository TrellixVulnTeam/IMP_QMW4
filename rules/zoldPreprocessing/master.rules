# output directory and log
P_OUT, P_LOG = prepare_environment('Preprocessing')


# skip or include preprocessing step fo MG data
if len(MG) == 2:
    include:
        "MG.rules"
    if config['preprocessing_filtering']:
        include:
            "MG.Filtering.rules"
    else:
        include:
            "MG.NoFiltering.rules"
if len(MG) == 3:
    include:
        "MG.skip.rules"

include:
    "MT.rules"

# include proper rules based on the filtering option
if config['preprocessing_filtering']:
    include:
        "MT.Filtering.rules"
else:
    include:
        "MT.NoFiltering.rules"


CHUNK_SIZE = 100 * 1024


def preprocessing_output_files():
    """
    Dynamically generate output files names based on parameters
    """
    return [
        '%s/MG.R1.preprocessed.fq' % P_OUT,
        '%s/MG.R2.preprocessed.fq' % P_OUT,
        '%s/MG.SE.preprocessed.fq' % P_OUT,
        '%s/MT.R1.preprocessed.fq' % P_OUT,
        '%s/MT.R2.preprocessed.fq' % P_OUT,
        '%s/MT.SE.preprocessed.fq' % P_OUT
    ]


def _process_file(fname, inp, outfilename):
    """
    Write the input to the output.
    """
    print(inp, '=>', outfilename)
    import bz2
    # ungunzip
    if os.path.splitext(fname)[-1] in ['.gz', '.gzip']:
        with open(outfilename, 'wb') as whandle, gzip.open(inp, 'rb') as rhandle:
            whandle.write(rhandle.read())
    # unbzip2
    elif os.path.splitext(fname)[-1] in ['.bz2', '.bzip2']:
        dec = bz2.BZ2Decompressor()
        with open(outfilename, 'wb') as whandle, open(inp, 'rb') as rhandle:
            for data in iter(lambda: rhandle.read(CHUNK_SIZE), b''):
                whandle.write(dec.decompress(data))
    # copy
    else:
        shutil.copy(inp, outfilename)


def prepare_paired_files(input, rtype):
    """
    Prepare Paired file analysis
    """
    for idx, inp in enumerate(input):
        if idx % 2 == 0:
            tmp = '%s.R1.fq' % rtype
        elif idx % 2 == 1:
            tmp = '%s.R2.fq' % rtype

        # get out path
        p, fname = os.path.split(inp)
        outfilename = os.path.join(P_OUT, tmp)
        _process_file(fname, inp, outfilename)


def skip_preprocessing(input, rtype):
    """
    Skip the preprocessing step as user provide R1, R2 and SE.
    """
    for idx, inp in enumerate(input):
        if idx % 3 == 0:
            tmp = '%s.R1.fq' % rtype
            stmp = '%s.R1.preprocessed.fq' % rtype
        elif idx % 3 == 1:
            tmp = '%s.R2.fq' % rtype
            stmp = '%s.R2.preprocessed.fq' % rtype
        elif idx % 3 == 2:
            tmp = '%s.SE.fq' % rtype
            stmp = '%s.SE.preprocessed.fq' % rtype

        # get out path
        p, fname = os.path.split(inp)
        outfilename = os.path.join(P_OUT, tmp)
        _process_file(fname, inp, outfilename)
        # symlink to the preprocessing output directory
        print('symlink',  tmp, '=>', stmp)
        os.symlink(outfilename, os.path.join(P_OUT, stmp))


def prepare_input_files(input, rtype):
    """
    Prepare file names from input.
    Will copy and/or ungzip paired input files into output directory named as '{rtype}.R1.fq' and '{rtype}.R2.fq'.
    If user provides R1, R2 and SE file, we rname the file as there were already preprocessed.
    input: input names from the user
    rtype: MG or MT
    """
    if len(input) < 2:
        raise OSError("//[IMP] %s files must be at least two paired files or two paired file and single end." % rtype)
    if len(input) == 2:
        prepare_paired_files(input, rtype)
    elif len(input) == 3:
        skip_preprocessing(input, rtype)

# master command
rule PREPROCESSING:
    input:
        preprocessing_output_files()
    benchmark:
        "%s/benchmarks/Preprocessing/preprocessing.json" % P_OUT
    shell:
        "echo 'Preprocessing Done'"
